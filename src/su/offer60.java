package su;

/**
 * n个骰子的点数
 *  求所有点数出现的概率，根据概率计算公式，点数K出现概率计算公式为：p(k)=k出现的次数/总次数
 *  总次数为6^n 因为n个骰子，每个骰子的点数都有6种可能出现的情况
 *  则目的就是计算出投完n个骰子后每个点数出现的次数
 *  使用递归求解：
 *      使用递归函数getCount(n,k)表示投n个骰子，点数k出现的次数
 *      假设n为2 求点数4和6 则getCount(2,4)=getCount(1,1)+getCount(1,2)+getCount(1,3)
 *      getCount(2,6)=getCount(1,1)+getCount(1,2)+getCount(1,3)+getCount(1,4)+getCount(1,5)
 *      则有大量重复计算
 *  使用动态规划求解：
 *     一般分为三步：表示状态  找出状态转移方程  边界处理
 *     表示状态：
 *          分析问题的状态时，不要分析整体，只分析最后一个阶段即可，因为每个阶段的状态表示都是一样，最终答案就在最后一个阶段
 *          最后一个阶段为：当投完n个骰子后，各个点数出现的次数
 *          找出了最后一个阶段 则状态表示为：
 *              用数组的第一维来表示阶段，也就是投了几个骰子
 *              用数组的第二维来表示投完这些骰子后 可能出现的次数
 *              数组的值就表示 该阶段各个点数出现的次数
 *          所以状态表示就是dp[i][j] 表示投完i个骰子后 点数j出现的次数
 *     找出状态转移方程
 *          找状态转移方程 就是找各个阶段之间的转化关系，同样还是分析最后一个阶段 最后一个阶段也就是投完n个骰子后的这个阶段
 *          用dp[n][j]来表示最后一个阶段点数j出现的次数 单看第n个骰子 它的点数可能为1-6， 因此投完n个骰子后点数j出现的次数
 *          可以由投完n-1个骰子后 对应点数j-1,j-2,j-3,...,j-6出现的次数之和转化过来(从n-1阶段转到n阶段的点数j 则可以由n-1阶段的j-1,..j-6
 *          来加上n阶段的点数)
 *          for(第n个骰子的点数 i=1;i<=6;i++) dp[n][j]+=dp[n-1][j-i]
 *     边界处理：
 *          只要我们把可以直接知道的状态初始化就好了
 *          可以直接知道第一阶段的状态：投完1个骰子后 它可能点数分别1-6 并且每个点数出现的次数都是1
 *
 *
 */
public class offer60 {
    public double[] dicesProbability(int n) {
        //因为阶段从1到n 则下标就是到n 则第一维长度为n+1  第二维点数是到6*n 则下标就是到6*n 则第二维长度为6*n+1
        //创建状态表示
        int[][] dp = new int[n + 1][6 * n + 1];
        //边界处理
        for(int i = 1; i <= 6; i++)
            dp[1][i] = 1;
        for(int i = 2; i <= n; i++)//第一层for 求每个阶段
            for(int j = i; j <= 6 * i; j++) //第二层for 求当前阶段下每个点数的次数
                for(int k = 1; k <= 6 && k <= j; k++) //第三层for 就是根据状态转移方程来求次数 注意 k <= j
                    dp[i][j] += dp[i-1][j - k];

        double[] ans = new double[6 * n - n + 1]; //点数出现次数的概率 最小点数为n 则长度为最大点数-最小点数+1个
        for(int i = n; i <= 6 * n; i++) //i从最小点数n开始
            ans[i - n] = ((double)dp[n][i]) / (Math.pow(6,n));
        return ans;
    }
}
